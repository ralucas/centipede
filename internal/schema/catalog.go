// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package schema

import "encoding/json"
import "fmt"
import "reflect"

// Validates an entire collection of Project Open Data metadata JSON objects.
// Agencies produce said collections in the form of Data.json files.
type CatalogJson struct {
	// URL or JSON object for the JSON-LD Context that defines the schema used
	Context *string `json:"@context,omitempty" yaml:"@context,omitempty" mapstructure:"@context,omitempty"`

	// IRI for the JSON-LD Node Identifier of the Catalog. This should be the URL of
	// the data.json file itself.
	Id *string `json:"@id,omitempty" yaml:"@id,omitempty" mapstructure:"@id,omitempty"`

	// IRI for the JSON-LD data type. This should be dcat:Catalog for the Catalog
	Type *CatalogJsonType `json:"@type,omitempty" yaml:"@type,omitempty" mapstructure:"@type,omitempty"`

	// Version of Schema
	ConformsTo CatalogJsonConformsTo `json:"conformsTo" yaml:"conformsTo" mapstructure:"conformsTo"`

	// Dataset corresponds to the JSON schema field "dataset".
	Dataset []DatasetJson `json:"dataset" yaml:"dataset" mapstructure:"dataset"`

	// URL for the JSON Schema file that defines the schema used
	DescribedBy *string `json:"describedBy,omitempty" yaml:"describedBy,omitempty" mapstructure:"describedBy,omitempty"`
}

type CatalogJsonConformsTo string

const CatalogJsonConformsToHttpsProjectOpenDataCioGovV11Schema CatalogJsonConformsTo = "https://project-open-data.cio.gov/v1.1/schema"

var enumValues_CatalogJsonConformsTo = []interface{}{
	"https://project-open-data.cio.gov/v1.1/schema",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CatalogJsonConformsTo) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CatalogJsonConformsTo {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CatalogJsonConformsTo, v)
	}
	*j = CatalogJsonConformsTo(v)
	return nil
}

type CatalogJsonType string

const CatalogJsonTypeDcatCatalog CatalogJsonType = "dcat:Catalog"

var enumValues_CatalogJsonType = []interface{}{
	"dcat:Catalog",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CatalogJsonType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CatalogJsonType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CatalogJsonType, v)
	}
	*j = CatalogJsonType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CatalogJson) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["conformsTo"]; raw != nil && !ok {
		return fmt.Errorf("field conformsTo in CatalogJson: required")
	}
	if _, ok := raw["dataset"]; raw != nil && !ok {
		return fmt.Errorf("field dataset in CatalogJson: required")
	}
	type Plain CatalogJson
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CatalogJson(plain)
	return nil
}

// The metadata format for all federal open data. Validates a single JSON object
// entry (as opposed to entire Data.json catalog).
type DatasetJson struct {
	// IRI for the JSON-LD data type. This should be dcat:Dataset for each Dataset
	Type *DatasetJsonType `json:"@type,omitempty" yaml:"@type,omitempty" mapstructure:"@type,omitempty"`

	// The degree to which this dataset could be made publicly-available, regardless
	// of whether it has been made available. Choices: public (Data asset is or could
	// be made publicly available to all without restrictions), restricted public
	// (Data asset is available under certain use restrictions), or non-public (Data
	// asset is not available to members of the public)
	AccessLevel DatasetJsonAccessLevel `json:"accessLevel" yaml:"accessLevel" mapstructure:"accessLevel"`

	// Frequency with which dataset is published.
	AccrualPeriodicity interface{} `json:"accrualPeriodicity,omitempty" yaml:"accrualPeriodicity,omitempty" mapstructure:"accrualPeriodicity,omitempty"`

	// Federal agencies, combined agency and bureau code from <a
	// href="http://www.whitehouse.gov/sites/default/files/omb/assets/a11_current_year/app_c.pdf">OMB
	// Circular A-11, Appendix C</a> in the format of <code>015:010</code>.
	BureauCode []string `json:"bureauCode" yaml:"bureauCode" mapstructure:"bureauCode"`

	// URI used to identify a standardized specification the dataset conforms to
	ConformsTo interface{} `json:"conformsTo,omitempty" yaml:"conformsTo,omitempty" mapstructure:"conformsTo,omitempty"`

	// ContactPoint corresponds to the JSON schema field "contactPoint".
	ContactPoint VcardJson `json:"contactPoint" yaml:"contactPoint" mapstructure:"contactPoint"`

	// Whether the dataset meets the agency’s Information Quality Guidelines
	// (true/false).
	DataQuality interface{} `json:"dataQuality,omitempty" yaml:"dataQuality,omitempty" mapstructure:"dataQuality,omitempty"`

	// URL to the data dictionary for the dataset or API. Note that documentation
	// other than a data dictionary can be referenced using Related Documents as shown
	// in the expanded fields.
	DescribedBy interface{} `json:"describedBy,omitempty" yaml:"describedBy,omitempty" mapstructure:"describedBy,omitempty"`

	// The machine-readable file format (IANA Media Type or MIME Type) of the
	// distribution’s describedBy URL
	DescribedByType interface{} `json:"describedByType,omitempty" yaml:"describedByType,omitempty" mapstructure:"describedByType,omitempty"`

	// Human-readable description (e.g., an abstract) with sufficient detail to enable
	// a user to quickly understand whether the asset is of interest.
	Description string `json:"description" yaml:"description" mapstructure:"description"`

	// A container for the array of Distribution objects
	Distribution interface{} `json:"distribution,omitempty" yaml:"distribution,omitempty" mapstructure:"distribution,omitempty"`

	// A unique identifier for the dataset or API as maintained within an Agency
	// catalog or database.
	Identifier string `json:"identifier" yaml:"identifier" mapstructure:"identifier"`

	// The collection of which the dataset is a subset
	IsPartOf interface{} `json:"isPartOf,omitempty" yaml:"isPartOf,omitempty" mapstructure:"isPartOf,omitempty"`

	// Date of formal issuance.
	Issued interface{} `json:"issued,omitempty" yaml:"issued,omitempty" mapstructure:"issued,omitempty"`

	// Tags (or keywords) help users discover your dataset; please include terms that
	// would be used by technical and non-technical users.
	Keyword []string `json:"keyword" yaml:"keyword" mapstructure:"keyword"`

	// Alternative landing page used to redirect user to a contextual, Agency-hosted
	// “homepage” for the Dataset or API when selecting this resource from the
	// Data.gov user interface.
	LandingPage interface{} `json:"landingPage,omitempty" yaml:"landingPage,omitempty" mapstructure:"landingPage,omitempty"`

	// The language of the dataset.
	Language interface{} `json:"language,omitempty" yaml:"language,omitempty" mapstructure:"language,omitempty"`

	// The license dataset or API is published with. See <a
	// href="https://project-open-data.cio.gov/open-licenses/">Open Licenses</a> for
	// more information.
	License interface{} `json:"license,omitempty" yaml:"license,omitempty" mapstructure:"license,omitempty"`

	// Most recent date on which the dataset was changed, updated or modified.
	Modified interface{} `json:"modified" yaml:"modified" mapstructure:"modified"`

	// For linking a dataset with an IT Unique Investment Identifier (UII)
	PrimaryITInvestmentUII interface{} `json:"primaryITInvestmentUII,omitempty" yaml:"primaryITInvestmentUII,omitempty" mapstructure:"primaryITInvestmentUII,omitempty"`

	// Federal agencies, list the primary program related to this data asset, from the
	// <a
	// href="http://goals.performance.gov/sites/default/files/images/FederalProgramInventory_FY13_MachineReadable_091613.xls">Federal
	// Program Inventory</a>. Use the format of <code>015:001</code>
	ProgramCode []string `json:"programCode" yaml:"programCode" mapstructure:"programCode"`

	// Publisher corresponds to the JSON schema field "publisher".
	Publisher OrganizationJson `json:"publisher" yaml:"publisher" mapstructure:"publisher"`

	// Related documents such as technical information about a dataset, developer
	// documentation, etc.
	References interface{} `json:"references,omitempty" yaml:"references,omitempty" mapstructure:"references,omitempty"`

	// This may include information regarding access or restrictions based on privacy,
	// security, or other policies. This should also provide an explanation for the
	// selected "accessLevel" including instructions for how to access a restricted
	// file, if applicable, or explanation for why a "non-public" or "restricted
	// public" data assetis not "public," if applicable. Text, 255 characters.
	Rights interface{} `json:"rights,omitempty" yaml:"rights,omitempty" mapstructure:"rights,omitempty"`

	// The range of spatial applicability of a dataset. Could include a spatial region
	// like a bounding box or a named place.
	Spatial interface{} `json:"spatial,omitempty" yaml:"spatial,omitempty" mapstructure:"spatial,omitempty"`

	// If the systems is designated as a system of records under the Privacy Act of
	// 1974, provide the URL to the System of Records Notice related to this dataset.
	SystemOfRecords interface{} `json:"systemOfRecords,omitempty" yaml:"systemOfRecords,omitempty" mapstructure:"systemOfRecords,omitempty"`

	// The range of temporal applicability of a dataset (i.e., a start and end date of
	// applicability for the data).
	Temporal interface{} `json:"temporal,omitempty" yaml:"temporal,omitempty" mapstructure:"temporal,omitempty"`

	// Main thematic category of the dataset.
	Theme interface{} `json:"theme,omitempty" yaml:"theme,omitempty" mapstructure:"theme,omitempty"`

	// Human-readable name of the asset. Should be in plain English and include
	// sufficient detail to facilitate search and discovery.
	Title string `json:"title" yaml:"title" mapstructure:"title"`
}

type DatasetJsonAccessLevel string

const DatasetJsonAccessLevelNonPublic DatasetJsonAccessLevel = "non-public"
const DatasetJsonAccessLevelPublic DatasetJsonAccessLevel = "public"
const DatasetJsonAccessLevelRestrictedPublic DatasetJsonAccessLevel = "restricted public"

var enumValues_DatasetJsonAccessLevel = []interface{}{
	"public",
	"restricted public",
	"non-public",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DatasetJsonAccessLevel) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_DatasetJsonAccessLevel {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_DatasetJsonAccessLevel, v)
	}
	*j = DatasetJsonAccessLevel(v)
	return nil
}

type DatasetJsonType string

const DatasetJsonTypeDcatDataset DatasetJsonType = "dcat:Dataset"

var enumValues_DatasetJsonType = []interface{}{
	"dcat:Dataset",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DatasetJsonType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_DatasetJsonType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_DatasetJsonType, v)
	}
	*j = DatasetJsonType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DatasetJson) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["accessLevel"]; raw != nil && !ok {
		return fmt.Errorf("field accessLevel in DatasetJson: required")
	}
	if _, ok := raw["bureauCode"]; raw != nil && !ok {
		return fmt.Errorf("field bureauCode in DatasetJson: required")
	}
	if _, ok := raw["contactPoint"]; raw != nil && !ok {
		return fmt.Errorf("field contactPoint in DatasetJson: required")
	}
	if _, ok := raw["description"]; raw != nil && !ok {
		return fmt.Errorf("field description in DatasetJson: required")
	}
	if _, ok := raw["identifier"]; raw != nil && !ok {
		return fmt.Errorf("field identifier in DatasetJson: required")
	}
	if _, ok := raw["keyword"]; raw != nil && !ok {
		return fmt.Errorf("field keyword in DatasetJson: required")
	}
	if _, ok := raw["modified"]; raw != nil && !ok {
		return fmt.Errorf("field modified in DatasetJson: required")
	}
	if _, ok := raw["programCode"]; raw != nil && !ok {
		return fmt.Errorf("field programCode in DatasetJson: required")
	}
	if _, ok := raw["publisher"]; raw != nil && !ok {
		return fmt.Errorf("field publisher in DatasetJson: required")
	}
	if _, ok := raw["title"]; raw != nil && !ok {
		return fmt.Errorf("field title in DatasetJson: required")
	}
	type Plain DatasetJson
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.BureauCode != nil && len(plain.BureauCode) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "bureauCode", 1)
	}
	if len(plain.Description) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "description", 1)
	}
	if len(plain.Identifier) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "identifier", 1)
	}
	if plain.Keyword != nil && len(plain.Keyword) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "keyword", 1)
	}
	if plain.ProgramCode != nil && len(plain.ProgramCode) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "programCode", 1)
	}
	if len(plain.Title) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "title", 1)
	}
	*j = DatasetJson(plain)
	return nil
}

// A Dataset Publisher Organization as a foaf:Agent object
type OrganizationJson struct {
	// IRI for the JSON-LD data type. This should be org:Organization for each
	// publisher
	Type *OrganizationJsonType `json:"@type,omitempty" yaml:"@type,omitempty" mapstructure:"@type,omitempty"`

	// A full formatted name, eg Firstname Lastname
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// SubOrganizationOf corresponds to the JSON schema field "subOrganizationOf".
	SubOrganizationOf *OrganizationJson `json:"subOrganizationOf,omitempty" yaml:"subOrganizationOf,omitempty" mapstructure:"subOrganizationOf,omitempty"`
}

type OrganizationJsonType string

const OrganizationJsonTypeOrgOrganization OrganizationJsonType = "org:Organization"

var enumValues_OrganizationJsonType = []interface{}{
	"org:Organization",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OrganizationJsonType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_OrganizationJsonType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_OrganizationJsonType, v)
	}
	*j = OrganizationJsonType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OrganizationJson) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in OrganizationJson: required")
	}
	type Plain OrganizationJson
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.Name) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "name", 1)
	}
	*j = OrganizationJson(plain)
	return nil
}

// A Dataset ContactPoint as a vCard object
type VcardJson struct {
	// IRI for the JSON-LD data type. This should be vcard:Contact for contactPoint
	Type *VcardJsonType `json:"@type,omitempty" yaml:"@type,omitempty" mapstructure:"@type,omitempty"`

	// A full formatted name, eg Firstname Lastname
	Fn string `json:"fn" yaml:"fn" mapstructure:"fn"`

	// Email address for the contact
	HasEmail string `json:"hasEmail" yaml:"hasEmail" mapstructure:"hasEmail"`
}

type VcardJsonType string

const VcardJsonTypeVcardContact VcardJsonType = "vcard:Contact"

var enumValues_VcardJsonType = []interface{}{
	"vcard:Contact",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VcardJsonType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_VcardJsonType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_VcardJsonType, v)
	}
	*j = VcardJsonType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VcardJson) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["fn"]; raw != nil && !ok {
		return fmt.Errorf("field fn in VcardJson: required")
	}
	if _, ok := raw["hasEmail"]; raw != nil && !ok {
		return fmt.Errorf("field hasEmail in VcardJson: required")
	}
	type Plain VcardJson
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.Fn) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "fn", 1)
	}
	*j = VcardJson(plain)
	return nil
}
